@page "/wallet/{type}/send"
@using System.Collections.Generic
@using System.Globalization
@using System.Linq
@using System.Threading
@using Microsoft.AspNetCore.Components.Web
@using ClickPay.Shared.Preferences
@using ClickPay.Shared.Pages
@using ClickPay.Wallet.Core.Services
@using ClickPay.Wallet.Core.CryptoAssets
@implements IDisposable
@inject NavigationManager Navigation
@inject LocalizationService Loc
@inject MultiChainWalletService Wallets
@inject WalletKeyService Vaults
@inject IQrScannerService QrScanner
@inject PaymentRequestParser PaymentParser
@inject FiatPreferenceStore FiatPreferences
@inject IExchangeRateService ExchangeRates

<PageTitle>@(overview is null ? Loc.T("SendPaymentButton") : string.Format(CultureInfo.CurrentCulture, Loc.T("SendPageTitle"), overview.Symbol))</PageTitle>

<div class="container py-4">
    @if (loading)
    {
        <div class="row justify-content-center">
            <div class="col-12 col-md-6 text-center py-5">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Loading...</span>
                </div>
            </div>
        </div>
    }
    else if (!string.IsNullOrEmpty(error))
    {
        <div class="row justify-content-center">
            <div class="col-12 col-md-8 col-lg-6">
                <div class="alert alert-danger" role="alert">@error</div>
            </div>
        </div>
    }
    else if (overview is not null)
    {
        <div class="row justify-content-center">
            <div class="col-12 col-lg-8 col-xl-6">
                @if (!string.IsNullOrEmpty(successMessage))
                {
                    <div class="alert alert-success d-flex align-items-center" role="alert">
                        <i class="bi bi-check-circle-fill me-2"></i>
                        <span>@successMessage</span>
                    </div>
                }
                @if (!string.IsNullOrEmpty(formError))
                {
                    <div class="alert alert-warning d-flex align-items-center" role="alert">
                        <i class="bi bi-exclamation-triangle-fill me-2"></i>
                        <span>@formError</span>
                    </div>
                }

                @if (ShowFeeNotice)
                {
                    <div class="alert alert-info" role="alert">
                        <i class="bi bi-info-circle-fill me-2"></i>
                        @Loc.T("SendFeeNoticeNetwork")
                    </div>

                    if (ShouldWarnFeeReserve && RecommendedFeeReserve is { } reserve)
                    {
                        <div class="alert alert-warning" role="alert">
                            <i class="bi bi-exclamation-triangle-fill me-2"></i>
                            @string.Format(CultureInfo.CurrentCulture, Loc.T("SendFeeWarningLowFee"), FeeReserveBalance.ToString("N4", CultureInfo.CurrentCulture), reserve.ToString("N4", CultureInfo.CurrentCulture))
                        </div>
                    }
                }

                <div class="card shadow-lg border-0">
                    <div class="card-body p-4">
                        <div class="mb-3">
                            <h2 class="wallet-asset-heading mb-0">
                                <span class="wallet-asset-title">
                                    @if (!string.IsNullOrEmpty(assetIconDataUri))
                                    {
                                        <img src="@assetIconDataUri" alt="@overview.Symbol" class="wallet-asset-title-icon wallet-icon-invert" />
                                    }
                                    else
                                    {
                                        <span class="wallet-asset-title-symbol">@GetAssetTitleSymbol()</span>
                                    }
                                    <span>@GetSendHeadingLabel()</span>
                                </span>
                                <span class="wallet-asset-heading-code text-muted">(@GetAssetCodeDisplay())</span>
                            </h2>
                        </div>
                        <p class="text-muted mb-4">@string.Format(CultureInfo.CurrentCulture, Loc.T("SendBalanceLabel"), overview.Balance.ToString("N4", CultureInfo.CurrentCulture), overview.Symbol)</p>

                        <div class="mb-3">
                            <label class="form-label" for="destinationInput">@Loc.T("SendDestinationLabel")</label>
                            <div class="input-group">
                                <span class="input-group-text"><i class="bi bi-wallet2"></i></span>
                                <input id="destinationInput" class="form-control" @bind="form.Destination" @bind:event="oninput" placeholder="@Loc.T("Address")" autocomplete="off" spellcheck="false" disabled="@(sending || scanning)" />
                                <button type="button" class="btn btn-outline-secondary" disabled="@(sending || scanning)" @onclick="ScanQrAsync">
                                    <i class="bi bi-qr-code-scan me-1"></i>@Loc.T("SendScanButton")
                                </button>
                            </div>
                        </div>

                        <div class="mb-3">
                            <label class="form-label" for="amountInput">@Loc.T("Amount") (@assetDefinition?.Code)</label>
                            <div class="input-group">
                                <span class="input-group-text"><i class="bi bi-cash-stack"></i></span>
                                <input id="amountInput" class="form-control" type="text" value="@cryptoAmountText" @oninput="OnCryptoAmountInput" @onblur="OnCryptoAmountBlur" placeholder="@GetCryptoPlaceholder()" inputmode="decimal" autocomplete="off" disabled="@sending" />
                                <button type="button" class="btn btn-outline-secondary" disabled="@sending" @onclick="SetMaxAmount">
                                    @Loc.T("SendMaxButton")
                                </button>
                            </div>
                            <div class="form-text">@string.Format(CultureInfo.CurrentCulture, Loc.T("SendBalanceLabel"), overview.Balance.ToString("N4", CultureInfo.CurrentCulture), overview.Symbol)</div>
                            @if (HasFiatRate)
                            {
                                <div class="form-text text-muted">@GetFiatRateDescription()</div>
                            }
                        </div>

                        @if (ShowFiatConversionField)
                        {
                            <div class="mb-3">
                                <label class="form-label" for="fiatAmountInput">@GetFiatAmountLabel()</label>
                                <div class="input-group">
                                    <span class="input-group-text"><i class="bi bi-currency-exchange"></i></span>
                                    <input id="fiatAmountInput" class="form-control" type="text" value="@fiatAmountText" @oninput="OnFiatAmountInput" @onblur="OnFiatAmountBlur" placeholder="@GetFiatPlaceholder()" inputmode="decimal" autocomplete="off" disabled="@(!CanEditFiatAmount || sending)" />
                                </div>
                                <div class="form-text">@GetFiatRateDescription()</div>
                            </div>
                        }

                        <div class="d-flex justify-content-center">
                            <button type="button" class="btn btn-primary btn-lg px-4" @onclick="SendAsync" disabled="@(sending || scanning)">
                                @if (sending)
                                {
                                    <span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>
                                }
                                @Loc.T("SendPaymentButton")
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    }
</div>

@code {
    private readonly SendForm form = new();

    [Parameter] public string? type { get; set; }
    [SupplyParameterFromQuery(Name = "payload")] public string? payload { get; set; }

    private string assetCode = string.Empty;
    private CryptoAsset? assetDefinition;
    private string? assetIconDataUri;
    private WalletOverview? overview;
    private bool loading = true;
    private bool awaitingInteractive;
    private bool sending;
    private bool scanning;
    private string? error;
    private string? formError;
    private string? successMessage;
    private bool payloadApplied;
    private string? currentType;
    private IReadOnlyList<CryptoAsset> feeAssetDefinitions = Array.Empty<CryptoAsset>();
    private readonly Dictionary<string, WalletOverview> feeAssetOverviews = new(StringComparer.OrdinalIgnoreCase);
    private bool storageRetryQueued;
    private FiatPreferenceStore.FiatCurrencyOption? fiatPreference;
    private CachedExchangeRate? cachedFiatRate;
    private string cryptoAmountText = string.Empty;
    private string fiatAmountText = string.Empty;
    private bool disposed;
    private bool cryptoInputActive;
    private bool fiatInputActive;

    private CryptoAsset? PrimaryFeeAsset => feeAssetDefinitions.FirstOrDefault();
    private decimal FeeReserveBalance
    {
        get
        {
            if (PrimaryFeeAsset is { } feeAsset && feeAssetOverviews.TryGetValue(feeAsset.Code, out var feeOverview))
            {
                return feeOverview.Balance;
            }

            return overview?.Balance ?? 0m;
        }
    }

    private decimal? RecommendedFeeReserve => assetDefinition?.NetworkFeeMinimumBalance;
    private bool ShowFeeNotice => feeAssetDefinitions.Count > 0 || RecommendedFeeReserve is { };
    private bool ShouldWarnFeeReserve => RecommendedFeeReserve is { } minimum && FeeReserveBalance < minimum;
    private bool SupportsFiatConversion => assetDefinition is { CoingeckoId.Length: > 0 };
    private bool HasFiatRate => cachedFiatRate is { Value: > 0m };
    private bool ShowFiatConversionField => SupportsFiatConversion && HasFiatRate;
    private bool CanEditFiatAmount => ShowFiatConversionField;

    private string GetCryptoPlaceholder() => WalletConversionHelpers.GetCryptoPlaceholder(assetDefinition?.Decimals ?? 4);

    private string GetFiatPlaceholder() => WalletConversionHelpers.GetFiatPlaceholder();

    private string GetFiatAmountLabel()
    {
        var unit = GetFiatDisplayUnit();
        return string.Format(CultureInfo.CurrentCulture, "Valore in {0}", unit);
    }

    private string GetFiatDisplayUnit()
    {
        if (fiatPreference is { Symbol: { Length: > 0 } symbol })
        {
            return symbol;
        }

        return fiatPreference?.Code ?? FiatPreferenceStore.DefaultCurrencyCode;
    }

    private string GetFiatRateDescription()
    {
        if (!SupportsFiatConversion)
        {
            return "La conversione in fiat non è disponibile per questo asset.";
        }

        if (!HasFiatRate)
        {
            return "Tasso di cambio in caricamento...";
        }

        var assetLabel = assetDefinition?.Symbol ?? assetDefinition?.Code ?? assetCode;
        var unit = GetFiatDisplayUnit();
        var rate = cachedFiatRate!.Value;
        return string.Format(CultureInfo.CurrentCulture, "~ 1 {0} ≈ {1} {2}", assetLabel, rate.ToString("N2", CultureInfo.CurrentCulture), unit);
    }

    private void OnCryptoAmountInput(ChangeEventArgs args)
    {
        cryptoInputActive = true;

        var text = args.Value?.ToString() ?? string.Empty;
        cryptoAmountText = text;

    if (!WalletConversionHelpers.TryParseDecimal(text, out var parsed))
        {
            if (string.IsNullOrWhiteSpace(text))
            {
                SetCryptoAmount(0m, updateFiat: true, formatDisplay: false);
            }

            cryptoInputActive = false;
            return;
        }

        var normalized = NormalizeCryptoAmount(parsed);
        SetCryptoAmount(normalized, updateFiat: true, formatDisplay: false);
        cryptoInputActive = false;
    }

    private void OnFiatAmountInput(ChangeEventArgs args)
    {
        fiatInputActive = true;

        var text = args.Value?.ToString() ?? string.Empty;
        fiatAmountText = text;

        if (!HasFiatRate || cachedFiatRate is not { Value: > 0m } rate)
        {
            fiatInputActive = false;
            return;
        }

    if (!WalletConversionHelpers.TryParseDecimal(text, out var parsed))
        {
            if (string.IsNullOrWhiteSpace(text))
            {
                SetCryptoAmount(0m, updateFiat: false, formatDisplay: false);
            }

            fiatInputActive = false;
            return;
        }

        var crypto = NormalizeCryptoAmount(parsed / rate.Value);
        SetCryptoAmount(crypto, updateFiat: false);
        fiatInputActive = false;
    }

    private void OnCryptoAmountBlur(FocusEventArgs _)
    {
        cryptoInputActive = false;
        if (disposed)
        {
            return;
        }

        SetCryptoAmount(form.Amount);
    }

    private void OnFiatAmountBlur(FocusEventArgs _)
    {
        fiatInputActive = false;
        if (disposed)
        {
            return;
        }

        UpdateFiatAmountFromCrypto();
    }

    private async Task LoadFiatContextAsync()
    {
        fiatPreference = await FiatPreferences.GetPreferredOptionAsync();

        if (!SupportsFiatConversion || assetDefinition is not { } asset)
        {
            cachedFiatRate = null;
            fiatAmountText = string.Empty;
            return;
        }

        try
        {
            var preferred = fiatPreference;
            if (preferred is null)
            {
                cachedFiatRate = null;
                return;
            }

            var rate = await ExchangeRates.GetRateAsync(asset, preferred.Code, ScheduleFiatRefresh);
            cachedFiatRate = rate is { Value: > 0m } valid ? valid : null;
        }
        catch
        {
            cachedFiatRate = null;
        }

        UpdateFiatAmountFromCrypto();
    }

    private void ScheduleFiatRefresh()
    {
        if (disposed || !SupportsFiatConversion || assetDefinition is not { } asset || fiatPreference is not { } preference)
        {
            return;
        }

        var fiat = preference.Code;

        _ = Task.Run(async () =>
        {
            try
            {
                var refreshed = await ExchangeRates.GetRateAsync(asset, fiat, null, CancellationToken.None).ConfigureAwait(false);
                if (disposed)
                {
                    return;
                }

                await InvokeAsync(() =>
                {
                    cachedFiatRate = refreshed is { Value: > 0m } valid ? valid : null;
                    UpdateFiatAmountFromCrypto();
                    StateHasChanged();
                });
            }
            catch
            {
                // Ignored: background refresh failures are non-fatal for the send form.
            }
        });
    }

    private void SetCryptoAmount(decimal amount, bool updateFiat = true, bool formatDisplay = true)
    {
        var normalized = NormalizeCryptoAmount(amount);
        form.Amount = normalized;

        if (formatDisplay && !cryptoInputActive)
        {
            cryptoAmountText = normalized > 0m
                ? WalletConversionHelpers.FormatCrypto(normalized, assetDefinition?.Decimals ?? 8)
                : string.Empty;
        }

        if (updateFiat && !fiatInputActive)
        {
            UpdateFiatAmountFromCrypto();
        }
    }

    private void UpdateFiatAmountFromCrypto()
    {
        if (disposed || fiatInputActive)
        {
            return;
        }

        if (!HasFiatRate)
        {
            fiatAmountText = string.Empty;
            return;
        }

        var fiatValue = form.Amount * cachedFiatRate!.Value;
        fiatAmountText = fiatValue > 0m
            ? WalletConversionHelpers.FormatFiat(fiatValue)
            : string.Empty;
    }

    private decimal NormalizeCryptoAmount(decimal amount)
    {
        if (amount <= 0m)
        {
            return 0m;
        }

        var decimals = assetDefinition?.Decimals ?? 8;
        var constrained = Math.Max(0m, amount);
        return decimals >= 0
            ? decimal.Round(constrained, decimals, MidpointRounding.ToZero)
            : constrained;
    }

    private string GetCryptoFormatString()
    {
        var decimals = assetDefinition?.Decimals ?? 8;
        if (decimals <= 0)
        {
            return "0";
        }

        return $"0.{new string('#', decimals)}";
    }

    protected override async Task OnParametersSetAsync()
    {
        if (!string.Equals(currentType, type, StringComparison.OrdinalIgnoreCase))
        {
            currentType = type;
            payloadApplied = false;
        }

        if (!WalletAssetHelper.TryParse(type, out var resolvedAsset))
        {
            error = Loc.T("ErrorUnsupportedAsset");
            loading = false;
            assetDefinition = null;
            assetIconDataUri = null;
            return;
        }

        try
        {
            assetDefinition = resolvedAsset;
            assetCode = assetDefinition.Code;
            feeAssetDefinitions = Array.Empty<CryptoAsset>();
            feeAssetOverviews.Clear();
            UpdateAssetIcon();
        }
        catch (Exception ex)
        {
            error = ex.Message;
            loading = false;
            assetIconDataUri = null;
            return;
        }

        if (awaitingInteractive)
        {
            return;
        }

        await InitializeAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!awaitingInteractive || firstRender)
        {
            return;
        }

        awaitingInteractive = false;
        await InitializeAsync();

        if (!awaitingInteractive)
        {
            StateHasChanged();
        }
    }

    private async Task InitializeAsync()
    {
        loading = true;
        formError = null;
        successMessage = null;
        SetCryptoAmount(form.Amount);

        try
        {
            if (!await Vaults.HasVaultAsync())
            {
                Navigation.NavigateTo("/onboarding", true);
                return;
            }

            overview = await Wallets.GetOverviewAsync(assetCode);

            await LoadFiatContextAsync();
            await RefreshFeeAssetOverviewsAsync();
            storageRetryQueued = false;

            loading = false;
            ApplyPayloadIfNeeded();
        }
        catch (SecureStorageUnavailableException)
        {
            if (!storageRetryQueued)
            {
                storageRetryQueued = true;
                awaitingInteractive = true;
            }
            else
            {
                error = Loc.T("StorageUnavailableError");
                awaitingInteractive = false;
                loading = false;
            }
        }
        catch (Exception ex)
        {
            error = ex.Message;
            loading = false;
        }
    }

    private async Task RefreshFeeAssetOverviewsAsync()
    {
        if (assetDefinition is null)
        {
            feeAssetDefinitions = Array.Empty<CryptoAsset>();
            feeAssetOverviews.Clear();
            return;
        }

        var feeCodes = WalletAssetHelper.GetFeeAssetCodes(assetDefinition);
        if (feeCodes.Count == 0)
        {
            feeAssetDefinitions = Array.Empty<CryptoAsset>();
            feeAssetOverviews.Clear();
            return;
        }

        var resolvedDefinitions = new List<CryptoAsset>(feeCodes.Count);
        foreach (var feeCode in feeCodes)
        {
            if (WalletAssetHelper.TryGetDefinition(feeCode, out var definition))
            {
                resolvedDefinitions.Add(definition);
            }
        }

        if (resolvedDefinitions.Count == 0)
        {
            feeAssetDefinitions = Array.Empty<CryptoAsset>();
            feeAssetOverviews.Clear();
            return;
        }

    feeAssetDefinitions = resolvedDefinitions.ToArray();

        feeAssetOverviews.Clear();

        var overviewTasks = feeAssetDefinitions
            .Select(definition => Wallets.GetOverviewAsync(definition.Code))
            .ToArray();

        var results = await Task.WhenAll(overviewTasks);

        for (var i = 0; i < feeAssetDefinitions.Count; i++)
        {
            var key = feeAssetDefinitions[i].Code;
            var overviewResult = results[i];
            if (overviewResult is null)
            {
                feeAssetOverviews.Remove(key);
            }
            else
            {
                feeAssetOverviews[key] = overviewResult;
            }
        }
    }

    private void ApplyPayloadIfNeeded()
    {
        if (payloadApplied || string.IsNullOrWhiteSpace(payload))
        {
            return;
        }

        ParseAndApplyPayload(payload, true);
    }

    private async Task SendAsync()
    {
        if (sending)
        {
            return;
        }

        formError = null;
        successMessage = null;

        if (string.IsNullOrWhiteSpace(form.Destination))
        {
            formError = Loc.T("ErrorDestinationRequired");
            return;
        }

        if (form.Amount <= 0m)
        {
            formError = Loc.T("ErrorInvalidAmount");
            return;
        }

        if (overview is null)
        {
            formError = Loc.T("ErrorUnsupportedAsset");
            return;
        }

        if (assetDefinition is null)
        {
            formError = Loc.T("ErrorUnsupportedAsset");
            return;
        }

        if (form.Amount > overview.Balance)
        {
            formError = Loc.T("SendErrorInsufficientFunds");
            return;
        }

        if (RecommendedFeeReserve is { } reserve && reserve > 0m)
        {
            var usesSelfAssetForFees = PrimaryFeeAsset is null || string.Equals(PrimaryFeeAsset.Code, assetDefinition.Code, StringComparison.OrdinalIgnoreCase);

            if (usesSelfAssetForFees)
            {
                var remaining = overview.Balance - form.Amount;
                if (remaining < reserve)
                {
                    formError = string.Format(
                        CultureInfo.CurrentCulture,
                        Loc.T("SendErrorFeeReserveRequired"),
                        reserve.ToString("N4", CultureInfo.CurrentCulture),
                        assetDefinition.Symbol ?? assetDefinition.Code);
                    return;
                }
            }
            else if (FeeReserveBalance < reserve)
            {
                formError = string.Format(
                    CultureInfo.CurrentCulture,
                    Loc.T("SendErrorFeeReserveRequired"),
                    reserve.ToString("N4", CultureInfo.CurrentCulture),
                    PrimaryFeeAsset?.Symbol ?? PrimaryFeeAsset?.Code ?? assetDefinition.Code);
                return;
            }
        }

        sending = true;

        try
        {
            var result = await Wallets.SendAsync(assetCode, form.Destination.Trim(), form.Amount);
            successMessage = string.Format(CultureInfo.CurrentCulture, Loc.T("TransactionSentFormat"), result.TransactionId);
            SetCryptoAmount(0m);

            overview = await Wallets.GetOverviewAsync(assetCode);
            await LoadFiatContextAsync();
            await RefreshFeeAssetOverviewsAsync();
        }
        catch (Exception ex)
        {
            formError = ex.Message;
        }
        finally
        {
            sending = false;
        }
    }

    private void SetMaxAmount()
    {
        if (overview is null || assetDefinition is null)
        {
            return;
        }

        formError = null;
        successMessage = null;

        var balance = overview.Balance;
        var amount = balance;

        if (RecommendedFeeReserve is { } reserve && reserve > 0m)
        {
            var usesSelfAssetForFees = PrimaryFeeAsset is null || string.Equals(PrimaryFeeAsset.Code, assetDefinition.Code, StringComparison.OrdinalIgnoreCase);

            if (usesSelfAssetForFees)
            {
                amount = Math.Max(0m, balance - reserve);

                if (amount <= 0m)
                {
                    SetCryptoAmount(0m);
                    formError = string.Format(
                        CultureInfo.CurrentCulture,
                        Loc.T("SendErrorFeeReserveRequired"),
                        reserve.ToString("N4", CultureInfo.CurrentCulture),
                        assetDefinition.Symbol ?? assetDefinition.Code);
                    return;
                }
            }
            else if (FeeReserveBalance < reserve)
            {
                SetCryptoAmount(0m);
                formError = string.Format(
                    CultureInfo.CurrentCulture,
                    Loc.T("SendErrorFeeReserveRequired"),
                    reserve.ToString("N4", CultureInfo.CurrentCulture),
                    PrimaryFeeAsset?.Symbol ?? PrimaryFeeAsset?.Code ?? assetDefinition.Code);
                return;
            }
        }

        var decimals = assetDefinition.Decimals;
        amount = decimal.Round(amount, decimals, MidpointRounding.ToZero);

        SetCryptoAmount(amount);
    }

    private async Task ScanQrAsync()
    {
        if (scanning)
        {
            return;
        }

        formError = null;
        scanning = true;

        try
        {
            var result = await QrScanner.ScanAsync(new QrScanRequest(
                assetCode,
                overview?.Symbol,
                Loc.T("QrScan_Prompt_Title"),
                Loc.T("QrScan_Prompt_Message"),
                Loc.T("QrScan_Prompt_Cancel")));

            if (result.Cancelled)
            {
                return;
            }

            if (!result.Success)
            {
                formError = Loc.T(result.ErrorCode ?? "QrScan_Error_Generic");
                return;
            }

            var payloadValue = result.Payload;
            if (string.IsNullOrWhiteSpace(payloadValue))
            {
                formError = Loc.T("QrScan_Error_NoData");
                return;
            }

            ParseAndApplyPayload(payloadValue, false);
        }
        catch (Exception ex)
        {
            formError = ex.Message;
        }
        finally
        {
            scanning = false;
        }
    }

    private void ParseAndApplyPayload(string rawPayload, bool fromQuery)
    {
        try
        {
            if (assetDefinition is null)
            {
                formError = Loc.T("ErrorUnsupportedAsset");
                return;
            }

            var parsed = PaymentParser.Parse(assetDefinition, rawPayload);
            if (!parsed.Success)
            {
                formError = Loc.T(parsed.ErrorCode ?? "QrScan_Error_Generic");
                return;
            }

            if (!string.IsNullOrWhiteSpace(parsed.Address))
            {
                form.Destination = parsed.Address;
            }

            if (parsed.Amount.HasValue)
            {
                SetCryptoAmount(parsed.Amount.Value);
            }

            formError = null;

            if (fromQuery)
            {
                payload = null;
            }
        }
        catch (Exception ex)
        {
            formError = ex.Message;
        }
        finally
        {
            if (fromQuery)
            {
                payloadApplied = true;
            }
        }
    }

    private sealed class SendForm
    {
        public string? Destination { get; set; }
        public decimal Amount { get; set; }
    }

    private string GetSendHeadingLabel()
    {
        var label = assetDefinition?.Name;
        if (string.IsNullOrWhiteSpace(label))
        {
            label = assetDefinition?.MenuLabel ?? overview?.Symbol ?? assetCode;
        }

        return Loc.FormatWalletLabel(label);
    }

    private string GetAssetCodeDisplay()
    {
        if (!string.IsNullOrWhiteSpace(assetDefinition?.Code))
        {
            return assetDefinition!.Code;
        }

        if (!string.IsNullOrWhiteSpace(assetCode))
        {
            return assetCode;
        }

        return overview?.Symbol ?? assetCode;
    }

    private string GetAssetTitleSymbol() => assetDefinition?.Symbol ?? overview?.Symbol ?? assetDefinition?.Code ?? assetCode;

    private void UpdateAssetIcon()
    {
        if (assetDefinition is not null && CryptoAssetIconResolver.TryGetIconDataUri(assetDefinition, out var iconUri) && IsPngDataUri(iconUri))
        {
            assetIconDataUri = iconUri;
        }
        else if (!string.IsNullOrWhiteSpace(assetCode) && CryptoAssetIconResolver.TryGetIconDataUri(assetCode, out var fallbackIcon) && IsPngDataUri(fallbackIcon))
        {
            assetIconDataUri = fallbackIcon;
        }
        else
        {
            assetIconDataUri = null;
        }
    }

    private static bool IsPngDataUri(string? value) => !string.IsNullOrEmpty(value) && value.StartsWith("data:image/png", StringComparison.OrdinalIgnoreCase);

    public void Dispose()
    {
        disposed = true;
    }
}
