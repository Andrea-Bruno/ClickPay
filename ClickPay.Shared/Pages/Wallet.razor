@page "/wallet/{type}"
@using ClickPay.Shared.Preferences
@using ClickPay.Shared.Services
@using ClickPay.Wallet.Core.Utility
@using ClickPay.Wallet.Core.CryptoAssets
@using System.Globalization
@using System.Threading
@using System.IO
@using System.Text
@using System.Linq
@using Microsoft.Extensions.Logging
@using Microsoft.JSInterop
@implements IDisposable

@inject NavigationManager Navigation
@inject LocalizationService Loc
@inject FiatPreferenceStore FiatPreferences
@inject IJSRuntime JS
@inject ILogger<Wallet> Logger
@inject HttpClient httpClient
@inject ClickPay.Wallet.Core.Services.ILocalSecureStore SecureStore
@using ClickPay.Wallet.Core.Blockchain
@inject WalletProviderRegistry ProviderRegistry

@if (loading)
{
    <div class="row">
        <div class="col-12 text-center py-5">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
        </div>
    </div>
}
else if (!string.IsNullOrEmpty(error))
{
    <div class="alert alert-danger" role="alert">
        @error
    </div>
}
else if (overview is not null)
{
    <div class="row mb-4">
        <div class="col-12 bg-primary bg-gradient text-white rounded-4 shadow-lg p-4">
            <h2 class="card-title">
                @if (assetDefinition is not null)
                {
                    @GetWalletHeading(assetDefinition)
                }
                else
                {
                    @(overview != null ? Loc.FormatWalletLabel(overview.Symbol) : Loc.T("WalletWelcomeTitle"))
                }
            </h2>
            <div class="display-4 my-3 text-primary wallet-balance-display text-white">
                @if (overview is not null)
                {
                    <span class="wallet-balance-amount">@overview.Balance.ToString("N4")</span>
                    @if (!string.IsNullOrEmpty(assetIconDataUri))
                    {
                        <img src="@assetIconDataUri" alt="@overview.Symbol" class="wallet-balance-icon" />
                    }
                    else
                    {
                        <span class="wallet-balance-symbol">@overview.Symbol</span>
                    }
                }
            </div>
            <div class="text-white">@Loc.T("WalletBalancePlaceholder")</div>
            <div class="mt-2">
                <span class="fs-5 text-white">≈ @((fiatValue ?? 0).ToString("N2")) @GetFiatDisplayUnit()</span>
            </div>
            @if (HasFeeAssets)
            {
                if (ShouldWarnFeeReserve)
                {
                    <div class="alert alert-warning mt-3">
                        <strong>@Loc.T("WalletFeeWarningTitle")</strong>
                        <span>@string.Format(CultureInfo.CurrentCulture, Loc.T("WalletFeeWarningRequirement"), GetMainAssetLabel(), FormatFeeAssetList())</span>
                        <span>@string.Format(CultureInfo.CurrentCulture, Loc.T("WalletFeeWarningBalance"), FormatFeeAssetList(), FormatAmount(FeeReserveBalance))</span>
                        @if (RecommendedFeeReserve is { } reserve)
                        {
                            <br />
                            <span>@string.Format(CultureInfo.CurrentCulture, Loc.T("WalletFeeWarningReserveRecommendation"), FormatFeeAssetList(), FormatAmount(reserve))</span>
                        }
                        @if (PrimaryFeeAsset is { } primaryFeeAsset)
                        {
                            <br />
                            <button class="btn btn-outline-primary mt-2" @onclick="() => OpenFeeAssetWallet(primaryFeeAsset.Code)">@string.Format(CultureInfo.CurrentCulture, Loc.T("WalletFeeOpenFeeWallet"), GetAssetShortLabel(primaryFeeAsset))</button>
                        }
                    </div>
                }
                else
                {
                    <div class="alert alert-info mt-3">
                        <span>@string.Format(CultureInfo.CurrentCulture, Loc.T("WalletFeeInfoRequirement"), GetMainAssetLabel(), FormatFeeAssetList())</span>
                        @if (RecommendedFeeReserve is { } reserve)
                        {
                            <br />
                            <span>@string.Format(CultureInfo.CurrentCulture, Loc.T("WalletFeeInfoRecommended"), FormatAmount(reserve), FormatFeeAssetList())</span>
                        }
                    </div>
                }
            }
            else if (IsNativeAsset)
            {
                <div class="alert alert-info mt-3">
                    @if (assetDefinition?.NetworkFeeMinimumBalance is { } nativeReserve && nativeReserve > 0m)
                    {
                        <span>@string.Format(CultureInfo.CurrentCulture, Loc.T("WalletFeeInfoNative"), GetMainAssetLabel(), FormatAmount(nativeReserve))</span>
                    }
                    else
                    {
                        <span>@string.Format(CultureInfo.CurrentCulture, Loc.T("WalletFeeInfoNativeGeneral"), GetMainAssetLabel())</span>
                    }
                </div>
            }
        </div>
    </div>
    <div class="row mb-4">
        <div class="col-12">
            <h4>@Loc.T("RecentTransactionsTitle")</h4>
            @if (transactions.Count == 0)
            {
                <div class="alert alert-secondary">@Loc.T("NoTransactionsMessage")</div>
            }
            else
            {
                <ul class="list-group">
                    @foreach (var tx in transactions)
                    {
                        <li class="list-group-item d-flex justify-content-between align-items-center">
                            <div>
                                <div class="fw-semibold address-complete">@tx.TransactionId</div>
                                <div class="fw-semibold address-abbr">@AbbreviateAddress(tx.TransactionId)</div>
                                <small class="text-muted">@tx.Timestamp.LocalDateTime.ToString("g")</small>
                            </div>
                            <span class="badge bg-@(tx.IsIncoming ? "success" : "danger")">
                                @(tx.IsIncoming ? "+" : "-")@tx.Amount.ToString("N4") @(overview != null ? overview.Symbol : "")
                            </span>
                        </li>
                    }
                </ul>
            }
        </div>
    </div>
}


@if (overview is not null && string.IsNullOrEmpty(error))
{
    <div class="wallet-action-bar fixed-bottom">
        <div class="container py-3">
            <div class="row g-3 justify-content-center">
                <div class="col-6 col-md-3 d-grid">
                    <button class="btn btn-success btn-lg" @onclick="ReceivePayment"> <span class="fs-1">▼</span><br /> @Loc.T("ReceivePaymentTitle")</button>
                </div>
                <div class="col-6 col-md-3 d-grid">
                    <button class="btn btn-primary btn-lg" @onclick="SendPayment"> <span class="fs-1">▲</span><br /> @Loc.T("SendPaymentButton")</button>
                </div>
            </div>
        </div>
    </div>
}


@code {
    [Parameter] public string? type { get; set; }
    private string assetCode = string.Empty;
    private WalletOverview? overview;
    private decimal? cachedFiatRate;
    private CryptoAsset? assetDefinition;
    private string? assetIconDataUri;
    private List<WalletTransaction> transactions = new();
    private bool loading = true;
    private string? error;
    private decimal? fiatValue;

    private string AbbreviateAddress(string address)
    {
        if (string.IsNullOrEmpty(address) || address.Length <= 15)
            return address;
        return $"{address.Substring(0, 6)}...{address.Substring(address.Length - 6)}";
    }
    // Transactions are loaded in LoadWalletAsync
    private FiatPreferenceStore.FiatCurrencyOption? fiatPreference;
    private bool awaitingInteractive;
    private readonly Dictionary<string, WalletOverview> feeAssetOverviews = new(StringComparer.OrdinalIgnoreCase);
    private readonly List<CryptoAsset> feeAssetDefinitions = new();
    private bool storageRetryQueued;
    private static readonly TimeSpan OperationTimeout = TimeSpan.FromSeconds(60);
    private static readonly SemaphoreSlim LogFileLock = new(1, 1);
    private static readonly string LogDirectory = Path.Combine(AppContext.BaseDirectory, "logs");
    private static readonly string LogFilePath = Path.Combine(LogDirectory, "wallet-agent.log");
    private bool logFileCleared;
    private bool disposed;

    private void ScheduleOverviewRefresh()
    {
        if (disposed)
        {
            return;
        }

        var asset = assetCode;

        _ = Task.Run(async () =>
        {
            try
            {
                var updated = await MultiChainWalletUtility.GetOverviewAsync(
                    ct => WalletKeyUtility.GetVaultAsync(SecureStore, ct),
                    ProviderRegistry,
                    Logger,
                    asset,
                    null,
                    CancellationToken.None).ConfigureAwait(false);
                if (disposed || updated is null)
                {
                    return;
                }

                overview = updated;
                transactions = new List<WalletTransaction>(updated.Transactions);

                if (cachedFiatRate is not null)
                {
                    fiatValue = updated.Balance * cachedFiatRate.Value;
                }

                await InvokeAsync(StateHasChanged);
            }
            catch (Exception ex)
            {
                Logger?.LogDebug(ex, "Unable to refresh overview for asset {Asset}.", asset);
            }
        });
    }

    private void ScheduleTransactionsRefresh()
    {
        if (disposed)
        {
            return;
        }

        var asset = assetCode;

        _ = Task.Run(async () =>
        {
            try
            {
                var refreshed = await MultiChainWalletUtility.GetTransactionsAsync(
                    ct => WalletKeyUtility.GetVaultAsync(SecureStore, ct),
                    ProviderRegistry,
                    Logger,
                    asset,
                    null,
                    CancellationToken.None).ConfigureAwait(false);
                if (disposed)
                {
                    return;
                }

                transactions = new List<WalletTransaction>(refreshed ?? Array.Empty<WalletTransaction>());

                if (overview is not null)
                {
                    overview = overview with { Transactions = transactions };
                }

                await InvokeAsync(StateHasChanged);
            }
            catch (Exception ex)
            {
                Logger?.LogDebug(ex, "Unable to refresh transactions for asset {Asset}.", asset);
            }
        });
    }

    private void ScheduleFeeAssetRefresh(string feeAssetCode)
    {
        if (disposed)
        {
            return;
        }

        _ = Task.Run(async () =>
        {
            try
            {
                var updated = await MultiChainWalletUtility.GetOverviewAsync(
                    ct => WalletKeyUtility.GetVaultAsync(SecureStore, ct),
                    ProviderRegistry,
                    Logger,
                    feeAssetCode,
                    null,
                    CancellationToken.None).ConfigureAwait(false);
                if (disposed)
                {
                    return;
                }

                if (updated is null)
                {
                    feeAssetOverviews.Remove(feeAssetCode);
                }
                else
                {
                    feeAssetOverviews[feeAssetCode] = updated;
                }

                await InvokeAsync(StateHasChanged);
            }
            catch (Exception ex)
            {
                Logger?.LogDebug(ex, "Unable to refresh fee asset overview for {Asset}.", feeAssetCode);
            }
        });
    }

    private void ScheduleFiatRefresh()
    {
        if (disposed || assetDefinition is null || fiatPreference is null)
        {
            return;
        }

        var definition = assetDefinition;
        var fiat = fiatPreference.Code;

        _ = Task.Run(async () =>
        {
            try
            {
                var refreshed = await ClickPay.Wallet.Core.MarketData.CoinGeckoExchangeRateUtility.GetRateAsync(httpClient, Logger, definition, fiat, null, CancellationToken.None).ConfigureAwait(false);
                if (disposed || refreshed is null)
                {
                    return;
                }

                cachedFiatRate = refreshed?.Value;

                if (overview is not null)
                {
                    if (refreshed != null)
                        fiatValue = overview.Balance * refreshed.Value;
                }

                await InvokeAsync(StateHasChanged);
            }
            catch (Exception ex)
            {
                Logger?.LogDebug(ex, "Unable to refresh fiat rate for {Asset}->{Fiat}.", definition.Code, fiat);
            }
        });
    }

    protected override async Task OnParametersSetAsync()
    {
        if (disposed)
        {
            return;
        }

        if (!WalletAssetHelper.TryParse(type, out var resolvedAsset))
        {
            error = Loc.T("ErrorUnsupportedAsset");
            loading = false;
            assetDefinition = null;
            assetIconDataUri = null;
            feeAssetDefinitions.Clear();
            feeAssetOverviews.Clear();
            return;
        }

        try
        {
            assetDefinition = resolvedAsset;
            assetCode = assetDefinition.Code;
            UpdateAssetIcon();
            UpdateFeeAssetDefinitions();
        }
        catch (Exception ex)
        {
            error = ex.Message;
            loading = false;
            feeAssetDefinitions.Clear();
            feeAssetOverviews.Clear();
            return;
        }

        try
        {
            fiatPreference = await FiatPreferences.GetPreferredOptionAsync();
        }
        catch (SecureStorageUnavailableException ex)
        {
            Logger?.LogWarning(ex, "Secure storage unavailable while loading fiat preference.");
            await AppendLogAsync("Secure storage unavailable while loading fiat preference.", ex);
            error = Loc.T("StorageUnavailableError");
            loading = false;
            awaitingInteractive = false;
            storageRetryQueued = false;
            return;
        }

        if (awaitingInteractive)
        {
            return;
        }

        await LoadWalletAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (disposed)
        {
            return;
        }

        if (!awaitingInteractive)
        {
            return;
        }

        if (firstRender)
        {
            await AppendLogAsync("OnAfterRenderAsync: awaiting interactive; skipping because firstRender=true.");
            return;
        }

        await AppendLogAsync("OnAfterRenderAsync: resuming wallet load after interactive connection established.");
        awaitingInteractive = false;
        await LoadWalletAsync();

        if (disposed)
        {
            return;
        }

        if (!awaitingInteractive)
        {
            await AppendLogAsync("OnAfterRenderAsync: wallet load completed; requesting UI update.");
            await InvokeAsync(StateHasChanged);
        }
    }

    private void UpdateAssetIcon()
    {
        if (assetDefinition is not null && CryptoAssetIconResolver.TryGetIconDataUri(assetDefinition, out var iconUri) && IsPngDataUri(iconUri))
        {
            assetIconDataUri = iconUri;
        }
        else if (!string.IsNullOrWhiteSpace(assetCode) && CryptoAssetIconResolver.TryGetIconDataUri(assetCode, out var fallbackIcon) && IsPngDataUri(fallbackIcon))
        {
            assetIconDataUri = fallbackIcon;
        }
        else
        {
            assetIconDataUri = null;
        }
    }

    private static bool IsPngDataUri(string? value)
    {
        return !string.IsNullOrEmpty(value) && value.StartsWith("data:image/png", StringComparison.OrdinalIgnoreCase);
    }

    private async Task<bool> UpdateFiatValueAsync(CancellationToken cancellationToken)
    {
        if (overview is null || assetDefinition is null)
        {
            return true;
        }

        var preference = fiatPreference ?? await FiatPreferences.GetPreferredOptionAsync();
        if (preference is null)
        {
            return true;
        }

        fiatPreference = preference;

        if (string.IsNullOrWhiteSpace(assetDefinition.CoingeckoId))
        {
            fiatValue = null;
            cachedFiatRate = null;
            return true;
        }

        var rate = await ClickPay.Wallet.Core.MarketData.CoinGeckoExchangeRateUtility.GetRateAsync(httpClient, Logger, assetDefinition, preference.Code, ScheduleFiatRefresh, cancellationToken);
        cachedFiatRate = rate?.Value;

        if (rate is not null)
        {
            fiatValue = overview.Balance * rate.Value;
        }

        return true;
    }

    private async Task LoadWalletAsync()
    {
        if (disposed)
        {
            return;
        }

        // Debugger.Break();
        await EnsureLogFileClearedAsync();
        loading = true;
        error = null;

        try
        {
            var vaultCheck = await RunWithTimeoutAsync(ct => WalletKeyUtility.HasVaultAsync(SecureStore, ct), Loc.T("WalletTimeoutVault"));
            if (disposed)
            {
                return;
            }

            if (!vaultCheck.Success)
            {
                return;
            }

            if (!vaultCheck.Result)
            {
                Navigation.NavigateTo("/", true);
                return;
            }

            var overviewResult = await RunWithTimeoutAsync(ct => MultiChainWalletUtility.GetOverviewAsync(
                    ct => WalletKeyUtility.GetVaultAsync(SecureStore, ct),
                ProviderRegistry,
                Logger,
                assetCode,
                ScheduleOverviewRefresh,
                ct), Loc.T("WalletTimeoutOverview"));
            if (disposed)
            {
                return;
            }

            if (!overviewResult.Success)
            {
                return;
            }

            overview = overviewResult.Result;
            if (overview is null)
            {
                error = Loc.T("ErrorUnsupportedAsset");
                loading = false;
                return;
            }

            var transactionsResult = await RunWithTimeoutAsync(ct => MultiChainWalletUtility.GetTransactionsAsync(
                    ct => WalletKeyUtility.GetVaultAsync(SecureStore, ct),
                ProviderRegistry,
                Logger,
                assetCode,
                ScheduleTransactionsRefresh,
                ct), Loc.T("WalletTimeoutTransactions"));
            if (disposed)
            {
                return;
            }

            if (transactionsResult.Success && transactionsResult.Result is not null)
            {
                transactions = new List<WalletTransaction>(transactionsResult.Result);
            }
            else
            {
                transactions = new List<WalletTransaction>(overview.Transactions);
            }
            fiatValue = null;
            cachedFiatRate = null;

            var fiatUpdate = await RunWithTimeoutAsync(ct => UpdateFiatValueAsync(ct), Loc.T("WalletTimeoutFiat"));
            if (disposed)
            {
                return;
            }

            if (!fiatUpdate.Success)
            {
                return;
            }

            UpdateFeeAssetDefinitions();

            var feeRefresh = await RefreshFeeAssetOverviewsAsync();
            if (disposed)
            {
                return;
            }

            if (!feeRefresh)
            {
                return;
            }

            storageRetryQueued = false;
        }
        catch (SecureStorageUnavailableException ex)
        {
            Logger?.LogWarning(ex, "Secure storage unavailable while loading wallet {AssetCode}. awaitingInteractive={Awaiting}", assetCode, awaitingInteractive);
            await AppendLogAsync($"Secure storage unavailable while loading wallet {assetCode}. awaitingInteractive={awaitingInteractive}", ex);
            if (!storageRetryQueued)
            {
                storageRetryQueued = true;
                awaitingInteractive = true;
                loading = true;
                error = null;
            }
            else
            {
                loading = false;
                error = Loc.T("StorageUnavailableError");
                awaitingInteractive = false;
            }
        }
        catch (Exception ex)
        {
            Logger?.LogError(ex, "Unhandled exception while loading wallet {AssetCode}", assetCode);
            await AppendLogAsync($"Unhandled exception while loading wallet {assetCode}", ex);
            error = ex.Message;
        }
        finally
        {
            if (!awaitingInteractive)
            {
                loading = false;
            }
        }
    }

    public void Dispose()
    {
        if (disposed)
        {
            return;
        }

        disposed = true;
    }

    private void ReceivePayment() => Navigation.NavigateTo($"/wallet/{type}/receive");
    private void SendPayment() => Navigation.NavigateTo($"/wallet/{type}/send");

    private string GetFiatDisplayUnit()
    {
        if (fiatPreference is { Symbol: { Length: > 0 } symbol })
        {
            return symbol;
        }

        return fiatPreference?.Code ?? FiatPreferenceStore.DefaultCurrencyCode;
    }

    private string GetWalletHeading(CryptoAsset definition)
    {
        var baseLabel = definition.MenuLabel;

        return Loc.FormatWalletLabel(baseLabel);
    }

    private bool HasFeeAssets => feeAssetDefinitions.Count > 0;

    private decimal FeeReserveBalance => feeAssetDefinitions.Sum(definition =>
        feeAssetOverviews.TryGetValue(definition.Code, out var overview) ? overview.Balance : 0m);

    private decimal? RecommendedFeeReserve => assetDefinition?.NetworkFeeMinimumBalance;

    private bool ShouldWarnFeeReserve => HasFeeAssets && (FeeReserveBalance <= 0m || (RecommendedFeeReserve is { } minimum && FeeReserveBalance < minimum));

    private CryptoAsset? PrimaryFeeAsset => feeAssetDefinitions.Count > 0 ? feeAssetDefinitions[0] : null;

    private bool IsNativeAsset => assetDefinition is { } definition && string.IsNullOrWhiteSpace(definition.ContractAddress);

    private void UpdateFeeAssetDefinitions()
    {
        feeAssetDefinitions.Clear();
        feeAssetOverviews.Clear();

        if (assetDefinition is null)
        {
            return;
        }

        var feeCodes = WalletAssetHelper.GetFeeAssetCodes(assetDefinition);
        if (feeCodes.Count == 0)
        {
            return;
        }

        foreach (var feeCode in feeCodes)
        {
            if (WalletAssetHelper.TryGetDefinition(feeCode, out var definition))
            {
                feeAssetDefinitions.Add(definition);
            }
        }
    }

    private async Task<bool> RefreshFeeAssetOverviewsAsync()
    {
        if (!HasFeeAssets)
        {
            feeAssetOverviews.Clear();
            return true;
        }

        foreach (var definition in feeAssetDefinitions)
        {
            var feeCode = definition.Code;
            var feeResult = await RunWithTimeoutAsync(ct => MultiChainWalletUtility.GetOverviewAsync(
                    ct => WalletKeyUtility.GetVaultAsync(SecureStore, ct),
                ProviderRegistry,
                Logger,
                feeCode,
                () => ScheduleFeeAssetRefresh(feeCode),
                ct), Loc.T("WalletTimeoutFeeBalance"));
            if (disposed)
            {
                return false;
            }

            if (!feeResult.Success)
            {
                return false;
            }

            if (feeResult.Result is null)
            {
                feeAssetOverviews.Remove(definition.Code);
                continue;
            }

            feeAssetOverviews[definition.Code] = feeResult.Result;
        }

        return true;
    }

    private void OpenFeeAssetWallet(string feeAssetCode)
    {
        if (string.IsNullOrWhiteSpace(feeAssetCode))
        {
            return;
        }

        if (WalletAssetHelper.TryGetDefinition(feeAssetCode, out var feeAsset))
        {
            var route = WalletAssetHelper.GetRouteSegment(feeAsset);
            Navigation.NavigateTo($"/wallet/{route}");
            return;
        }

        Navigation.NavigateTo($"/wallet/{feeAssetCode.ToLowerInvariant()}");
    }

    private string GetMainAssetLabel()
        => assetDefinition is not null ? GetAssetLabel(assetDefinition) : overview?.Symbol ?? assetCode;

    private static string GetAssetLabel(CryptoAsset asset)
    {
        var name = !string.IsNullOrWhiteSpace(asset.Name) ? asset.Name : asset.Code;
        if (string.IsNullOrWhiteSpace(asset.Code) || string.Equals(name, asset.Code, StringComparison.OrdinalIgnoreCase))
        {
            return name;
        }

        return $"{name} ({asset.Code})";
    }

    private static string GetAssetShortLabel(CryptoAsset asset)
    {
        if (!string.IsNullOrWhiteSpace(asset.Code))
        {
            return asset.Code;
        }

        if (!string.IsNullOrWhiteSpace(asset.Name))
        {
            return asset.Name;
        }

        return "asset";
    }

    private string FormatFeeAssetList()
    {
        if (!HasFeeAssets)
        {
            return string.Empty;
        }

        return string.Join(", ", feeAssetDefinitions.Select(GetAssetShortLabel));
    }

    private static string FormatAmount(decimal value) => value.ToString("N4", CultureInfo.CurrentCulture);

    private async Task<(bool Success, T? Result)> RunWithTimeoutAsync<T>(Func<CancellationToken, Task<T>> operation, string errorMessage)
    {
        using var cts = new CancellationTokenSource(OperationTimeout);

        try
        {
            var result = await operation(cts.Token);
            return (true, result);
        }
        catch (OperationCanceledException) when (cts.IsCancellationRequested)
        {
            Logger?.LogWarning("Operation timed out after {TimeoutSeconds}s while loading wallet {AssetCode}", OperationTimeout.TotalSeconds, assetCode);
            await AppendLogAsync($"Operation timeout after {OperationTimeout.TotalSeconds}s while loading wallet {assetCode}");
            await NotifyTimeoutAsync(errorMessage);
        }
        catch (TimeoutException)
        {
            Logger?.LogWarning("TimeoutException thrown after {TimeoutSeconds}s while loading wallet {AssetCode}", OperationTimeout.TotalSeconds, assetCode);
            await AppendLogAsync($"TimeoutException thrown after {OperationTimeout.TotalSeconds}s while loading wallet {assetCode}");
            await NotifyTimeoutAsync(errorMessage);
        }

        return (false, default);
    }

    private async Task NotifyTimeoutAsync(string message)
    {
        if (disposed)
        {
            return;
        }

        Logger?.LogWarning("Wallet timeout message surfaced to UI: {Message}", message);
        await AppendLogAsync($"Wallet timeout surfaced to UI: {message}");
        error = message;
        loading = false;
        awaitingInteractive = false;

        try
        {
            await JS.InvokeVoidAsync("alert", message);
        }
        catch (JSException)
        {
            Logger?.LogWarning("Timeout alert suppressed because JS interop is not available yet.");
            await AppendLogAsync("Timeout alert suppressed because JS interop is not available yet.");
        }
        catch (InvalidOperationException ex) when (ex.Message.Contains("JavaScript interop", StringComparison.OrdinalIgnoreCase))
        {
            Logger?.LogWarning(ex, "Timeout alert could not be shown because JS interop is unavailable.");
            await AppendLogAsync("Timeout alert could not be shown because JS interop is unavailable.", ex);
        }
    }

    private async Task EnsureLogFileClearedAsync()
    {
        if (logFileCleared)
        {
            return;
        }

        await LogFileLock.WaitAsync();
        try
        {
            if (logFileCleared)
            {
                return;
            }

            if (!Directory.Exists(LogDirectory))
            {
                Directory.CreateDirectory(LogDirectory);
            }

            await File.WriteAllTextAsync(LogFilePath, string.Empty, Encoding.UTF8);
            logFileCleared = true;
        }
        finally
        {
            LogFileLock.Release();
        }
    }

    private async Task AppendLogAsync(string message, Exception? exception = null)
    {
        await EnsureLogFileClearedAsync();

        var builder = new StringBuilder()
            .Append('[')
            .Append(DateTime.UtcNow.ToString("O"))
            .Append("] ")
            .AppendLine(message);

        if (exception is not null)
        {
            builder.AppendLine(exception.ToString());
        }

        await LogFileLock.WaitAsync();
        try
        {
            await File.AppendAllTextAsync(LogFilePath, builder.ToString(), Encoding.UTF8);
        }
        finally
        {
            LogFileLock.Release();
        }
    }
}
